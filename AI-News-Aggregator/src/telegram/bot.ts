import { Telegraf } from "telegraf";
import { DailyDigest, DigestSection } from "../types";

export class TelegramDigestBot {
  private bot: Telegraf;
  private channelId: string;

  constructor(botToken: string, channelId: string) {
    this.bot = new Telegraf(botToken);
    this.channelId = channelId;
  }

  /**
   * Format and post the daily digest to the channel
   */
  async postDigest(digest: DailyDigest): Promise<void> {
    const messages = this.formatDigest(digest);

    for (const message of messages) {
      await this.bot.telegram.sendMessage(this.channelId, message, {
        parse_mode: "HTML",
        disable_web_page_preview: true,
      });

      // Small delay between messages
      await this.sleep(500);
    }
  }

  /**
   * Format digest into Telegram messages (split if too long)
   */
  private formatDigest(digest: DailyDigest): string[] {
    const messages: string[] = [];
    const dateStr = digest.date.toLocaleDateString("en-US", {
      weekday: "long",
      year: "numeric",
      month: "long",
      day: "numeric",
    });

    // Header message
    let header = `ğŸ“° <b>Daily News Digest</b>\n`;
    header += `ğŸ“… ${dateStr}\n\n`;
    header += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
    messages.push(header);

    // Section messages
    for (const section of digest.sections) {
      const sectionMessage = this.formatSection(section);
      messages.push(sectionMessage);
    }

    // Footer with stats
    let footer = `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;
    footer += `ğŸ“Š <b>Today's Summary:</b>\n`;
    footer += `â€¢ ${digest.stats.totalArticles} articles processed\n`;
    footer += `â€¢ ${digest.stats.factChecksPerformed} fact-checks performed\n`;
    footer += `â€¢ ${digest.stats.categoriesCovered} categories covered\n\n`;
    footer += `ğŸ¤– <i>Generated by AI News Aggregator</i>`;
    messages.push(footer);

    return messages;
  }

  /**
   * Format a single section
   */
  private formatSection(section: DigestSection): string {
    const categoryName = this.getCategoryDisplayName(section.category);
    let message = `${section.emoji} <b>${categoryName}</b>\n\n`;

    for (const article of section.articles) {
      message += `â–ªï¸ <b>${this.escapeHtml(article.headline)}</b>\n`;
      message += `${this.escapeHtml(article.summary)}\n`;

      // Fact check status
      if (article.factCheckStatus === "verified") {
        message += `âœ… <i>Fact-checked: Verified</i>\n`;
      } else if (article.factCheckStatus === "warning") {
        message += `âš ï¸ <i>${this.escapeHtml(article.factCheckNote || "Unverified claims")}</i>\n`;
      }

      // Sources
      if (article.sources.length > 0) {
        message += `ğŸ“ Sources: ${article.sources.join(", ")}\n`;
      }

      message += `\n`;
    }

    return message;
  }

  /**
   * Get display name for category
   */
  private getCategoryDisplayName(category: string): string {
    const names: Record<string, string> = {
      technology: "TECHNOLOGY",
      politics: "POLITICS",
      business: "BUSINESS",
      sports: "SPORTS",
      entertainment: "ENTERTAINMENT",
      science: "SCIENCE",
      health: "HEALTH",
      world: "WORLD NEWS",
      other: "OTHER",
    };
    return names[category] || category.toUpperCase();
  }

  /**
   * Get emoji for category
   */
  static getCategoryEmoji(category: string): string {
    const emojis: Record<string, string> = {
      technology: "ğŸ”·",
      politics: "ğŸ›ï¸",
      business: "ğŸ’¼",
      sports: "âš½",
      entertainment: "ğŸ¬",
      science: "ğŸ”¬",
      health: "ğŸ¥",
      world: "ğŸŒ",
      other: "ğŸ“Œ",
    };
    return emojis[category] || "ğŸ“Œ";
  }

  /**
   * Escape HTML special characters
   */
  private escapeHtml(text: string): string {
    return text
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;");
  }

  /**
   * Send a simple text message
   */
  async sendMessage(text: string): Promise<void> {
    await this.bot.telegram.sendMessage(this.channelId, text, {
      parse_mode: "HTML",
    });
  }

  /**
   * Send error notification
   */
  async sendError(error: string): Promise<void> {
    const message = `âš ï¸ <b>News Aggregator Error</b>\n\n${this.escapeHtml(error)}`;
    await this.bot.telegram.sendMessage(this.channelId, message, {
      parse_mode: "HTML",
    });
  }

  private sleep(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}
